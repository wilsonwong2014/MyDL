#!/bin/bash

#bash脚本_正则表达式 (2013-06-04 14:30:13)
#http://blog.sina.com.cn/s/blog_43c625f10101f5cp.html
#摘要：
#1、正则元字符
#2、[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}    
#      3个数字-2个数字-4个数字
#3、ab(oratorie)?s       
#      匹配labs或者laboratories，可以用于全称或者缩写的匹配
#4、egrep "(^| )[\"[{(]*book[\"]})?!.;:'s]*( |$)"  bookwords           
#      文本中搜索book，允许带有复数，但是不包括其他单词
#5、"[^"]*"                  
#      匹配最短的""内容
#6、sed 's/\([0-9][0-9]*\)\.\{5,\}\([0-9][0-9]*\)\/\1-\2/'  sample              
#      将两个数字中间超过5个点换成-
#
#1、概述
#       在bash执行环境中，我们讲到了通配符的用法。这里要注意的是，正则表达式与shell脚本
#   内置的通配符不同，shell通配符主要用于对文件名展开，因此是很简单的一种正则；而这里要
#   讲解的正则表达式在grep,sed,awk等工具中经常用到，可以做非常强大的匹配操作。想要系统了
#   解正则表达式的同学，建议学习《sed与awk》的第三章。
#
#2、元字符
#       一个正则表达式包括了普通字符集和元字符，元字符又包括锚（比如表示开头和结尾）和修饰
#   符（用于扩展或缩小匹配范围）。元字符列举如下：
#
#   星号        -- * -- 匹配前一个字符的任意多次(包括零次).
#               "1133*"匹配11 + 一个或更多的3 + 可能的其他字符: 113, 1133, 111312, 等等.
#
#   点          -- . -- 匹配除了新行符之外的任意一个字符. [1]
#               "13." 匹配13 + 至少一个任意字符(包括空格): 1133, 11333, 但不匹配 13(因为
#               少了附加的至少一个任意字符).
#
#   脱字符      -- ^ -- 匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定
#               一个字符集的意思.
#
#   美元符      -- $ -- 在正则表达式中匹配行尾.
#               "^$" 匹配空行.
#
#   方括号      -- [...] -- 在正则表达式中表示匹配括号中的一个字符.
#               "[xyz]"    匹配字符x, y, 或z.
#               "[c-n]"    匹配从字符c到n之间的任意一个字符.
#               "[B-Pk-y]" 匹配从B到P 或从k到y的任意一个字符.
#               "[a-z0-9]" 匹配任意小写字母或数字.
#               "[^b-d]"   匹配除了从b到d范围内所有的字符. 这是正则表达式中反转意思或取否的一
#                          个例子.(就好像在别的情形中!字符所扮演的角色).
#
#               多个方括号字符集组合使用可以匹配一般的单词和数字模式.
#               "[Yy][Ee][Ss]" 匹配yes, Yes, YES, yEs, 等等.
#               "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]"匹配社会安全码(Social Security number).
#
#   反斜杠字符  -- \ -- 转义(escapes) 一个特殊的字符,使这个字符表示原来字面上的意思.
#               "\$"表示了原来的字面意思"$",而不是在正则表达式中表达的匹配行尾的意思.
#               同样,"\\"也被解释成了字面上的意思"\".
#
#   转义(escape)"尖角号"
#              -- \<...\> -- 用于表示单词的边界.
#              尖角号必须被转义,因为不这样做的话它们就表示单纯的字面意思而已.
#              "\" 匹配单词"the",但不匹配"them", "there", "other",等等.
#
#以上都是基本的元字符，还有一些扩展的元字符，在egrep,awk等工具中使用。
#   问号      -- ? -- 匹配零或一个前面的字符. 它一般用于匹配单个字符.
#
#   加号      -- + -- 匹配一个或多个前面的字符.它的作用和*很相似,但唯一的区别是它不匹配零个字符的情况.
#
#             1 # GNU 版本的 sed 和 awk 可以使用"+",
#             2 # 但它应该转义一下.
#             3
#             4 echo a111b | sed -ne '/a1\+b/p'
#             5 echo a111b | grep 'a1\+b'
#             6 echo a111b | gawk '/a1+b/'
#             7 # 上面三句都是等价的效果.
#             8
#             9 # 多谢, S.C.
#
#   转义"大括号"
#            -- \{ \} -- 指示前面正则表达式匹配的次数.
#            要转义是因为不转义的话大括号只是表示他们字面上的意思.这个用法只是技巧上的而不是基本正则表达式的内容.
#
#            "[0-9]\{5\}" 精确匹配5个数字 (从 0 到 9的数字).
#                注意:    大括号不能在“经典”(不是POSIX兼容)的正则表达式版本的awk中使用. 然而, gawk 有一个选项--re-interval
#            来允许使用大括号(不必转义).
#                bash$ echo 2222 | gawk --re-interval '/2{3}/'
#                         2222
#                Perl和一些egrep版本不要求转义大括号.
#
#   圆括号   -- ( ) -- 括起一组正则表达式. 它和下面要讲的"|"操作符或在用expr进行子字符串提取(substring extraction)一起使用很有用.
#
#   竖线     -- | -- "或"正则操作符用于匹配一组可选的字符.
#            #bash$ egrep 're(a|e)d' misc.txt
#            People who read seem to be better informed than those who do not.
#            The clarinet produces sound by the vibration of its reed.
#
#还有一类POSIX字符类.    [:class:]   是另一种用于指定匹配字符范围的方法.
#   [:alnum:]    匹配字母和数字.等同于A-Za-z0-9.
#   [:alpha:]    匹配字母. 等同于A-Za-z.
#   [:blank:]    匹配一个空格或是一个制表符(tab).
#   [:cntrl:]    匹配控制字符.
#   [:digit:]    匹配(十进制)数字. 等同于0-9.
#   [:graph:]    (可打印的图形字符). 匹配 ASCII 码值的33 - 126之间的字符. 这和下面提到的[:print:]一样,但是不包括空格字符.
#   [:lower:]    匹配小写字母. 等同于a-z.
#   [:print:]    (可打印字符). 匹配 ASCII码值 32 - 126之间的字符. 这和上面提到的[:graph:]一样,但是增多一个空格字符.
#   [:space:]    匹配空白字符 (空格符和水平制表符).
#   [:upper:]    匹配大写字母. 等同于A-Z.
#   [:xdigit:]   匹配十六进制数字. 等同于0-9A-Fa-f.
#
#注意:    POSIX字符类一般都要求用引号或是双方括号double brackets ([[ ]])引起来.
#         bash$ grep [[:digit:]] test.file
#         abc=723
#
#         这些字符类在一个受限的范围内甚至可能用在shell通配(globbing)中.
#         bash$ ls -l ?[[:digit:]][[:digit:]]?
#         -rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b
#
#3、正则表达式举例
#   chapter.                  匹配chapter后面跟任意字符，不包括chapter出现在行尾。
#   [Ww]hat                   匹配What和what，也匹配somewhat
#   \.H[12345]                匹配.H1 , .H2 , .H3 , .H4 , .H5
#   [cC]hapter [1-9]          匹配chapter 9 , Chapter 1
#   [A-Za-z][.?!]             任意字母后跟.?!
#   [0-1][0-9][-/][0-3][0-9][-/][0-9][0-9]              MM-DD-YY或MM/DD/YY
#   \.DS "[^1]"               避免匹配.DS"1"
#   "*hyper"*                 不论是否有""，hyper都被匹配
#   .*                        匹配所有
#   <.*>                      匹配带<>
#   can[no']*t                匹配can't , can not ,cannot , cant等
#   80[234]?86                匹配8086 , 80286 , 80386 ,80486
#   ^$                        匹配空行
#   ^.*$                      匹配所有行
#   11*0                      匹配10 , 110, 1111110等
#   [0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}    3个数字-2个数字-4个数字
#   UNIX|LINUX                匹配UNIX或LINUX
#   lab(oratorie)?s           匹配labs或者laboratories，可以用于全称或者缩写的匹配
#   egrep "(^| )[\"[{(]*book[\"]})?!.;:'s]*( |$)"  bookwords           文本中搜索book，允许带有复数，但是不包括其他单词
#   A.*Z                      匹配最长情况
#   "[^"]*"                   匹配最短的""内容
#   sed 's/\([0-9][0-9]*\)\.\{5,\}\([0-9][0-9]*\)\/\1-\2/'  sample              将两个数字中间超过5个点换成-
#
###########################################


